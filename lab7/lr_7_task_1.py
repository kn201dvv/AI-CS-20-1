# -*- coding: utf-8 -*-
"""LR_7_task_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Y8JwG9Zs_SACmWlJdgmkF-p9TSpIC0M
"""

import numpy as np
table_distances = np.array( [
[	 np.inf,	645,	868,	125,	748,	366,	256,	316,	1057,	382,	360,	471,	428,	593,	311,	844,	602,	232,	575,	734,	521,	120,	343,	312,	396], #1
[645,	 np.inf,	252,	664,	81,	901,	533,	294,	394,	805,	975,	343,	468,	196,	957,	446,	430,	877,	1130,	213,	376,	765,	324,	891,	672], #2
[868,	252,	 np.inf,	858,	217,	1171,	727,	520,	148,	1111,	1221,	611,	731,	390,	1045,	591,	706,	1100,	1391,	335,	560,	988,	547,	1141,	867], #3
[125,	664,	858,	 np.inf,	738,	431,	131,	407,	1182,	257,	423,	677,	557,	468,	187,	803,	477,	298,	671,	690,	624,	185,	321,	389,	271], #4
[748,	81,	217,	738,	 np.inf,	1119,	607,	303,	365,	681,	833,	377,	497,	270,	925,	365,	477,	977,	1488,	287,	297,	875,	405,	957,	747], #5
[366,	901,	1171,	431,	1119,	 np.inf,	561,	618,	1402,	328,	135,	747,	627,	898,	296,	1070,	908,	134,	280,	1040,	798,	246,	709,	143,	701], #6
[256,	533,	727,	131,	607,	561,	 np.inf,	298,	811,	388,	550,	490,	489,	337,	318,	972,	346,	427,	806,	478,	551,	315,	190,	538,	149], #7
[316,	294,	520,	407,	303,	618,	298,	 np.inf, 668,	664,	710,	174,	294,	246,	627,	570,	506,	547,	883,	387,	225,	435,	126,	637,	363], #8
[1057,394,	148,	1182,	365,	1402,	811,	668,	 np.inf,	1199,	1379,	857,	977,	474,	1129,	739,	253, 1289, 1539, 333, 806, 1177,	706,	1292,	951], #9
[382, 805,	1111,	257,	681,	328,	388,	664,	1199, np.inf,	152,	780,	856,	725,	70,	1052,	734,	159,	413,	866,	869,	263,	578,	336,	949], #10
[360,	975,	1221,	423,	833,	135,	550,	710, 1379,	152,	 np.inf,	850,	970,	891,	232,	1173,	896,	128,	261,	1028,	1141,	240,	740,	278,	690], #11
[471,	343,	611,	677,	377,	747,	490,	174,	857,	780,	850,	 np.inf,	120,	420,	864,	282,	681,	754,	999,	556, 51,	590,	300,	642,	640], #12
[428,	468,	731,	557,	497,	627,	489,	294,	977,	856,	970,	120,	 np.inf,	540,	741,	392,	800,	660,	1009,	831, 171,	548,	420,	515,	529], #13
[593,	196,	390,	468,	270,	898,	337,	246,	474,	725,	891,	420,	540,	 np.inf,	665,	635, 261,	825,	1149,	141,	471,	653,	279,	892,	477], #14
[311,	957,	1045,	187,	925,	296,	318,	627,	1129,	70,	232,	864,	741,	665,	 np.inf,	1157,	664,	162,	484,	805,	834,	193,	508,	331,	458], #15
[844,	446,	591,	803,	365,	1070,	972,	570,	739,	1052,	1173,	282,	392,	635,	1157,	 np.inf, 896,	1097,	1363,	652,	221,	964,	696,	981,	1112], #16
[602,	430,	706,	477,	477,	908,	346,	506,	253,	734,	896,	681,	800,	261,	664,	896,	 np.inf,	774,	1138,	190,	732,	662,	540,	883,	350], #17
[232,	877,	1100,	298,	977,	134,	427,	547,	1289,	159,	128,	754,	660,	825,	162,	1097,	774,	 np.inf,	338,	987,	831,	112,	575,	176,	568], #18
[575,	1130,	1391,	671,	1488,	280,	806,	883,	1539,	413,	261,	999,	1009,	1149,	484,	1363,	1138,	338,	 np.inf, 1299,	1065,	455,	984,	444,	951], #19
[734,	213,	335,	690,	287, 1040,	478,	387,	333,	866,	1028,	556,	831,	141,	805,	652,	190,	987,	1299, np.inf, 576,	854,	420,	1036,	608], #20
[521,	376,	560,	624,	297,	798,	551,	225,	806,	869,	1141,	51,	171,	471,	834,	221,	732,	831,	1065, 576,	 np.inf,	641,	351,	713,	691], #21
[120,	765,	988,	185,	875,	246,	315,	435,	1177,	263,	240,	590,	548,	653,	193,	964,	662,	112,	455,	854,	641,	 np.inf,	463,	190,	455], #22
[343,	324,	547,	321,	405,	709,	190,	126,	706,	578,	740,	300,	420,	279,	508,	696,	540,	575,	984,	420,	351,	463,	 np.inf,	660, 330], #23
[312,	891,	1141,	389,	957,	143,	538,	637,	1292,	336,	278,	642,	515,	892,	331,	981,	883,	176, 444,	1036,	713,	190,	660,	 np.inf,	695], #24
[396,	672,	867,	271,	747,	701,	149,	363,	951,	949,	690,	640,	529,	477,	458,	1112,	350,	568,	951,	608,	691,	455,	330,	695,	 np.inf], #25
])

table_cities = ['Вінниця','Дніпро','Донецьк','Житомир','Запоріжжя',
                'Ів-Франківськ','Київ','Кропивницький','Луганськ','Луцьк',
                'Львів','Миколаїв','Одеса','Полтава','Рівне',
                'Сімферополь','Суми','Тернопіль','Ужгород','Харків',
                'Херсон','Хмельницький','Черкаси','Чернівці','Чернігів']

import random as rn
import numpy as np
from numpy.random import choice as np_choice

class AntAlgorithm(object):
    def __init__(self, distances, start, n_ants, n_best, n_iterations, decay, alpha=1, beta=1):
        # Ініціалізація класу AntAlgorithm з необхідними параметрами
        self.distances = distances
        self.start = start
        self.pheromone = np.ones(self.distances.shape) / len(distances)
        self.all_inds = range(len(distances))
        self.n_ants = n_ants
        self.n_best = n_best
        self.n_iterations = n_iterations
        self.decay = decay
        self.alpha = alpha
        self.beta = beta
        self.current_position = start
        self.next_position = None
        self.results = []

    def get_started(self):
            shortest_path = None # Найкоротший маршрут на поточній ітерації
            all_time_shortest_path = ("placeholder", np.inf) # Найкоротший маршрут за всі ітерації
            for i in range(1, self.n_iterations + 1):
                all_paths = self.get_rout() # Отримання всіх маршрутів мурашок
                self.spread_pheronome(all_paths, self.n_best, shortest_path)  # Розповсюдження феромонів
                shortest_path = min(all_paths, key=lambda x: x[1])   # Знаходження найкоротшого маршруту на поточній ітерації
                if shortest_path[1] < all_time_shortest_path[1]:
                    all_time_shortest_path = shortest_path  # Оновлення найкоротшого маршруту за всі ітерації
                self.pheromone = self.pheromone * self.decay  # Зменшення феромонів

                 # Виведення результату кожної 50-ї ітерації та останньої ітерації
                if i % 50 == 0 or i == self.n_iterations:
                    print("Step {}: {}".format(i, shortest_path[0]))
                    print("Total Distance: {} km".format(all_time_shortest_path[1]))
                    self.results.append((i, shortest_path[0], all_time_shortest_path[1]))

            return all_time_shortest_path, self.results if self.n_iterations > 0 else (None, [])



    def spread_pheronome(self, all_paths, n_best, shortest_path):

   # Розповсюдження феромонів на шляхах з найкращими маршрутами.

   # :param all_paths: Список усіх маршрутів
   # :param n_best: Кількість кращих маршрутів
   # :param shortest_path: Найкоротший маршрут на попередній ітерації

        sorted_paths = sorted(all_paths, key=lambda x: x[1])
        for path, dist in sorted_paths[:n_best]:
            for move in path:
                self.pheromone[move] += 1.0 / self.distances[move]

    def get_total_distance(self, path):

   #  Отримання загальної відстані для даного маршруту.
   # :param path: Маршрут
   # :return: Загальна відстань маршруту

        total_dist = 0
        for ele in path:
            total_dist += self.distances[ele]
        return total_dist

    def get_rout(self):
   # Отримання маршрутів для всіх мурашок.
   # :return: Список маршрутів для всіх мурашок

        all_paths = []
        for i in range(self.n_ants):
            path = self.get_path(self.current_position)
            all_paths.append((path, self.get_total_distance(path)))
        return all_paths

    def get_path(self, start):

   # Отримання маршруту для одного мурашки.

   # :param start: Початкове місто для мурашки
   # :return: Маршрут для мурашки

        path = []
        tabu = set()
        tabu.add(start)
        previous_step = start
        for i in range(len(self.distances) - 1):
            move = self.get_next_position(self.pheromone[previous_step], self.distances[previous_step], tabu)
            path.append((previous_step, move))
            previous_step = move
            tabu.add(move)
        self.next_position = start
        path.append((previous_step, start))
        self.current_position = self.next_position
        return path

    def get_next_position(self, pheromone, dist, tabu):

  #  Отримання наступної позиції для мурашки.

  #  :param pheromone: Матриця феромонів для поточної позиції
  #  :param dist: Матриця відстаней для поточної позиції
  #  :param tabu: Множина заборонених позицій
  #  :return: Наступна позиція для мурашки

        pheromone = np.copy(pheromone)
        pheromone[list(tabu)] = 0

        row = pheromone ** self.alpha * ((1.0 / dist) ** self.beta)

        norm_row = row / row.sum()
        move = np_choice(self.all_inds, 1, p=norm_row)[0]
        return move


n_ants = len(table_cities)
n_best = 3
n_iterations = 250
decay = 0.95
start = 3 # variant 4

ant_algorithm = AntAlgorithm(table_distances, start, n_ants, n_best, n_iterations, decay, 1, 1)
final_path, iteration_results = ant_algorithm.get_started()

import time

# Початок вимірювання часу
start_time = time.time()
n_ants = 5
n_best = 1
n_iterations = 250
decay = 0.95
start = 3 # variant 4

ant_algorithm = AntAlgorithm(table_distances, start, n_ants, n_best, n_iterations, decay, 1, 1)
final_path, iteration_results = ant_algorithm.get_started()
# Завершення вимірювання часу
end_time = time.time()

# Виведення часу виконання
execution_time = end_time - start_time
print(f"Час виконання: {execution_time} секунд")

# Початок вимірювання часу
start_time = time.time()
n_ants = len(table_cities)
n_best = 1
n_iterations = 50
decay = 0.95
start = 3 # variant 4

ant_algorithm = AntAlgorithm(table_distances, start, n_ants, n_best, n_iterations, decay, 1, 1)
final_path, iteration_results = ant_algorithm.get_started()
# Завершення вимірювання часу
end_time = time.time()

# Виведення часу виконання
execution_time = end_time - start_time
print(f"Час виконання: {execution_time} секунд")

# Початок вимірювання часу
start_time = time.time()
n_ants = len(table_cities)
n_best = 10
n_iterations = 500
decay = 0.99
start = 3 # variant 4

ant_algorithm = AntAlgorithm(table_distances, start, n_ants, n_best, n_iterations, decay, 1, 1)
final_path, iteration_results = ant_algorithm.get_started()
# Завершення вимірювання часу
end_time = time.time()

# Виведення часу виконання
execution_time = end_time - start_time
print(f"Час виконання: {execution_time} секунд")

import matplotlib.pyplot as plt

# Витягуємо індекси з найкоротшого маршруту та збільшуємо кожне значення на 1
path_indices = [i[0] + 1 for i in final_path[0]]
num_cities = 25
# Вказуємо позначки на осі x як числа від 1 до 25
x_ticks = range(1, num_cities + 1)

# Отримання результатів для кожної 50-ї ітерації
for result in iteration_results:
    iteration_number, iteration_path, iteration_distance = result

    # Витягуємо індекси з маршруту ітерації та збільшуємо кожне значення на 1
    iteration_indices = [i[0] + 1 for i in iteration_path]

    # Побудова графіка для маршруту ітерації зі спеціальними позначками та відзначеннями на осі y
    fig, ax = plt.subplots(figsize=(12, max(6, 0.3 * num_cities)))
    ax.plot(x_ticks, iteration_indices, marker='o', linestyle='-', color='red', label=f'Iteration {iteration_number} ({iteration_distance:.2f} km)')
    ax.set_yticks(range(1, num_cities + 1))
    ax.set_yticklabels(table_cities, fontsize=10)   # Використовуємо назви міст як мітки на осі y
    ax.set_xticks(x_ticks)
    plt.title(f'Маршрут пройдений мікровояжером (Ітерація {iteration_number})', fontsize=16)
    plt.xlabel('Номера міст', fontsize=14)
    plt.ylabel('Назви міст', fontsize=14)
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.legend()
    plt.show()