# -*- coding: utf-8 -*-
"""lr_4_task_8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vVWWMrfR9oC-UB_WwV8ZuWeFIJWhGHvt
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from sklearn import neighbors, datasets

# Завантаження вхідних даних
input_file = 'data.txt'
data = np.loadtxt(input_file, delimiter=',')
X, y = data[:, :-1], data[:, -1].astype(int)

# Відображення вхідних даних на графіку
plt.figure()
plt.title('Вхідні дані')
marker_shapes = 'v^os'
mapper = [marker_shapes[i] for i in y]

for i in range(X.shape[0]):
    plt.scatter(X[i, 0], X[i, 1], marker=mapper[i], s=75, edgecolors='black', facecolors='none')

plt.show()

# Кількість найближчих сусідів
num_neighbors = 12

# крок сітки
step_size = 0.01

# Створення класифікатора на основі методу k найближчих сусідів
from sklearn.neighbors import KNeighborsClassifier
classifier = KNeighborsClassifier(n_neighbors=num_neighbors, weights='distance')

# Навчання моделі на основі методу k найближчих сусідів
classifier.fit(X,y)

# Створення сітки для відображення меж на графіку
x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
x_values, y_values = np.meshgrid(np.arange(x_min, x_max, step_size), np.arange(y_min, y_max, step_size))

# Виконання класифікатора на всіх точках сітки
output = classifier.predict(np.c_[x_values.ravel(), y_values.ravel()])

# Візуалізація передбачуваного результату
output = output. reshape (x_values.shape)
plt.figure()
plt.pcolormesh(x_values, y_values, output, cmap=cm.Paired)

# Накладання навчальних точок на карту
for i in range(X.shape[0]):
    plt.scatter(X[i, 0], X[i, 1], marker=mapper[i], s=50, edgecolors='black', facecolors='none')

#граничні значення для осей Х та У та вкажемо заголовок
plt.xlim(x_values.min(), x_values.max())
plt.ylim(y_values.min(), y_values.max())

plt.title('Границі можелі класифікатора на основі найближчих к сусідів')

# Тестування вхідної точки даних
test_datapoint = [5.1, 3.6]

plt.figure()
plt.title('Тестова точка даних')

for i in range(X.shape[0]):
    plt.scatter(X[i, 0], X[i, 1], marker='o', s=75, edgecolors='black', facecolors="none")

plt.scatter(test_datapoint[0], test_datapoint[1], marker='x', linewidth=6, s=200, color='black')

plt.show()

# Вилучення K найближчих сусідів
_, indices = classifier.kneighbors([test_datapoint] )
indices = indices.astype(int) [0]

# Відображення K найближчих сусідів на графіку
plt.figure()
plt.title('K Найближчі сусіди')

# Створіть масив кольорів для позначок K найближчих сусідів
colors = ['r' if i in indices else 'b' for i in range(X.shape[0])]

for i in range(X.shape[0]):
    plt.scatter(X[i, 0], X[i, 1], marker=mapper[i], s=75, edgecolors='black', facecolors=colors[i])

# Відобразимо на тому ж графіку тестову точку
plt.scatter(test_datapoint[0], test_datapoint[1], marker='x', linewidth=6, s=200, facecolors='black')

# Виведемо прогнозований результат
predicted_output = classifier.predict([test_datapoint])[0]
print("Predicted output:", predicted_output)

plt.show()

# Виведемо прогнозований результат
predicted_output = classifier.predict([test_datapoint])[0]
print("Predicted output:", predicted_output)