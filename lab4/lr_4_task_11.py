# -*- coding: utf-8 -*-
"""lr_4_task_11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pxt_OyDie90Mx0vil7SC5BFdBqFvMyd6
"""

import argparse
import json
import numpy as np

def pearson_score(user1_ratings, user2_ratings):
    # фільми, які оцінили обидва користувачі
    common_movies = [movie for movie in user1_ratings if movie in user2_ratings]

    if not common_movies:
        return 0  # Повертаємо 0, якщо немає спільних оцінок

    #  середні оцінки кожного користувача для спільних фільмів
    user1_mean = np.mean([user1_ratings[movie] for movie in common_movies])
    user2_mean = np.mean([user2_ratings[movie] for movie in common_movies])

    #  чисельник і знаменник для формули Пірсона
    numerator = sum((user1_ratings[movie] - user1_mean) * (user2_ratings[movie] - user2_mean) for movie in common_movies)
    denominator_user1 = np.sqrt(sum((user1_ratings[movie] - user1_mean)**2 for movie in common_movies))
    denominator_user2 = np.sqrt(sum((user2_ratings[movie] - user2_mean)**2 for movie in common_movies))

    if denominator_user1 == 0 or denominator_user2 == 0:
        return 0  # Повертаємо 0, якщо один з користувачів не має дисперсії

    #  коефіцієнт кореляції Пірсона
    pearson = numerator / (denominator_user1 * denominator_user2)

    return pearson

# Визначимо функцію, яка знаходитиме в наборі даних користувачів, аналогічних зазначеному.
def find_similar_users(dataset, input_user, num_users):
    if input_user not in dataset:
        raise TypeError('Cannot find ' + input_user + ' in the dataset')

    # Оцінюємо подібність користувача до інших користувачів та зберігаємо результати
    scores = np.array([[x, pearson_score(dataset[input_user], dataset[x])] for x in dataset if x != input_user])

    # Сортування оцінок за спаданням
    scores_sorted = scores[scores[:, 1].argsort()[::-1]]

   # Вилучення оцінок перших 'num_users' користувачів
    top_users = scores_sorted[:num_users]

    return top_users

# Визначимо функцію для парсингу вхідних аргументів.
def build_arg_parser():
    parser = argparse.ArgumentParser(description='Find movie recommendations for the given user')
    parser.add_argument('--user', dest='user', required=True, help='Input user')
    return parser

# Отримати рекомендації щодо фільмів
# для вказаного користувача
def get_recommendations(dataset, input_user):
    if input_user not in dataset:
        raise TypeError('Cannot find ' + input_user + ' in the dataset')

# Визначимо змінні для відстеження оцінок.
    overall_scores = {}
    similarity_scores = {}
#Обчислимо оцінку подібності між вказаним користувачем та всіма
#іншими користувачами у наборі даних.
    for user in [x for x in dataset if x != input_user]:
        similarity_score = pearson_score(dataset[input_user], dataset[user])
       # Якщо оцінка подібності менша за 0, переходимо до наступного
        if similarity_score <= 0:
            continue
#Відслідкуємо зважену рейтингову оцінку для кожного елемента
#відфільтрованого списку, виходячи з оцінок подібності.
        for item in dataset[user]:
            if item not in dataset[input_user] or dataset[input_user][item] == 0:
                overall_scores[item] = overall_scores.get(item, 0) + dataset[user][item] * similarity_score
                similarity_scores[item] = similarity_scores.get(item, 0) + similarity_score
#У разі відсутності відповідних фільмів, ми не можемо надати жодних рекомендацій.

    if len(overall_scores) == 0:
        return ['No recommendations possible']
# Генерація рейтингів фільмів за допомогою їх нормалізації
    movie_scores = np.array([[score / similarity_scores[item], item] for item, score in overall_scores.items()])
  # Сортування за спаданням
    movie_scores = movie_scores[np.argsort(movie_scores[:, 0])[::-1]]
  # Вилучення рекомендацій фільмів
    movie_recommendations = [movie for _, movie in movie_scores]
    return movie_recommendations

# Визначимо основну функцію
if __name__ == '__main__':
    user = "Julie Hammel"
    ratings_file = 'ratings.json'


    with open(ratings_file, 'r') as f:
        data = json.loads(f.read())

    print("Data loaded successfully.")
    print(data.get(user, "User not found in the dataset"))

    movies = get_recommendations(data, user)

    if movies == ['No recommendations possible']:
        print("No movie recommendations available.")
    else:
        print("\nMovie recommendations for " + user + ":")
        for i, movie in enumerate(movies):
            print(str(i + 1) + '. ' + movie)